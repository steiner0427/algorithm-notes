definition : SCC

SCC는 Vertex전체집합의 부분집합으로, 임의의 두 정점 사이의 양방향 경로가 모두 존재해야한다.

타잔알고리즘 증명

우선 스패닝 트리의 간선을 자르는것으로 정점 집합을 분리함으로써, 모든 SCC를 찾을 수 있음을 증명한다.

그다음, 간선을 끊어야하는 조건을 생각해보자. 

부모 u → 자식 v로 가는 간선을 생각해볼때, 

v에서 u의 조상(dfs를 쳤을때 u보다 방문번호가 작은) 으로 연결되지 않는다면, SCC의 조건에 위배되므로 v는 u와 같은 SCC가 아니며 이에따라 간선을 끊으면 된다.(실제 구현에서는 u를 루트로 하는 서브트리가 스택 형태로 저장되어있고, 이 스택에서 조건을 만족하는 u가 나올때까지 뽑음으로서 구현한다.)

그렇다면 v가 조상으로 연결되는지 아닌지는 어떻게 따지면 될까? 기본적으로는 v에서 dfs를 시행한 결과값중 가장 작은 방문번호를 사용하면 되지만, 이것은 V^2의 시간이 걸리므로 비효율적이다. 대신, 재귀적으로 아래의 서브트리를 모두 처리해놓으면 더 빠르게 구할 수 있다. 한 정점 v에서 방문할 수 있는 최소 방문번호를, 앞으로 low[v]라고 나타내자.

생각해보면, low[v]를 구하는것은 앞에서 언급한 dfs처럼 v에 대한 모든 서브트리를 탐색할 필요가 없다. 각 정점마다 low값을 모두 저장하고 있으면, 서브트리의 루트는 반드시 해당 서브트리에서 가장 작은 low값을 자신의 low값으로 가지고 있기때문이다(이건 그냥 직관적으로 생각하면되는게, v에서 low값이 가장 작은 정점까지 이동하고, 그 정점에서 low번호에 해당하는 u의 조상으로 이동한다는 해를 고려하면 끝이다.)

따라서 v에서의 low값을 구하기위해 모든 정점에 대해 dfs를 칠 필요 없이, v와 연결된 서브트리의 루트(그니까 vf랑 연결된 정점)에 대해서만 low값을 구하고 최소값을 계산하면된다.

 그 케이스는 3가지로 나눌 수 있다.

1. 연결된 정점중 u의 조상(혹은 u)과 즉시 연결되는 backedge가 있는경우

2. u의 자식으로 연결되는경우

3.u의 조상도, 자식도 아닌경우

1의 경우, u의 조상과 연결되므로 visit값은 1일것이다. 이때는 num값과 low값중 작은값을 리턴하면 된다.

2의경우, v의 자식이므로 visit값은 0이며 두 정점의 low값중 작은 값을 리턴하면 된다.

3의경우 num값이 존재하지만, 스택에 있음을 나타내는 visit값을 확인하여 1번과 구별할 수 있다.

이제, 간선을 끊는 v의 조건을 정의하면, num==low일때라고 할 수 있다.